# goland快捷键

> 设置-->按键映射-->安装Eclipse快捷键插件

| 快捷键  | 作用 |
| --- | --- |
| CTRL+D |  删除一行代码    |
| ALT+<- | 退出代码     |
|     ALT+->   |     进入代码         |
|        |              |

# go语言基础

## HelloWorld

```go
package main

import "fmt"

func main() {
	fmt.Println("hello world")
}

```

> 编译：go build .\hello.go
>
> 编译运行：go run .\hello.go 

要设置package main并有main函数，这个go文件才能编译运行

同一个目录中的所有go文件只能有一个main函数，否则报错，goland不报错是因为<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240516224259107.png" alt="image-20240516224259107" style="zoom:50%;" />



## 变量

### 变量定义

```go
package main

import "fmt"

// 定义在main函数外为全局变量
// 这里定义的全局变量没有用到不会报错
// var name = "tom"
// var ok bool //布尔类型默认值false
// 上面两行代码通常这样写：
var (
	name = "tom"
	ok   bool
)

//简洁变量定义不能作用于全局变量
//age:=1 //报错

func main() {
	//go是静态语言
	/*
		1、变量先定义后使用
		2、变量必须有类型
		3、类型定义后不能改变
		4、同一作用域 变量名不能冲突
		5、简洁变量定义不能作用于全局变量
		6、变量有默认值
	*/

	//变相定义方式：
	//var age int=1 //类型定义在后边
	//var age=1		//int可省略，自动类型推断
	age := 100 //:=为赋值符号，可以省略var
	//go语言中局部变量定义后不使用会报错
	fmt.Println(age)

	//多变量定义
	//var user1, user2, user3 string //默认为空字符串
	var user1, user2, user3 = "tom1", 1, "tom3"
	fmt.Println(user1, user2, user3)

}

```

### 匿名变量

```go
package main

import "fmt"

// 定义一个函数
func a() (int, bool) {
	return 0, false
}

func main() {
	// 匿名变量，定义后但是不想使用
	var _ int
	//比如这里的r1我们不关心，我们只关心返回ok值有没有成功
	//r1, ok := a()
	_, ok := a() //改成匿名变量接收
	if ok {
		//如果不使用 _ 匿名变量接收，那我们必须要使用下r1变量，否则报错
		//fmt.Println(r1)
	}

}

```

### 变量作用域

```go
package main

import "fmt"

func main() {
	/*
		变量的作用域为定义的{}中
	*/

	{
		name := "hah"
		fmt.Println(name) //hah
	}
	//fmt.Println(name)//访问不到

	var age = 100
	if age == 100 {
		age := 1
		fmt.Println(age) //1
	}
	fmt.Println(age) //100
}

```

## 常量

```go
package main

import "fmt"

func main() {
	//显式定义常量
	const PI float64 = 3.1415926
	//隐式定义
	const PI2 = 3.1415926

	//命名：大写，单词间使用_连接

	//可以一组常量定义
	const (
		UNKNOW = 1
		FEMALE = 2
		MALE   = 3
	)

	const (
		x int = 16
		y
		s = "abc"
		z
	)
	fmt.Println(x, y, s, z) //16 16 abc abc
	/* 默认规则：
	1、常量类型定义只支持 bool、数值（整数、浮点数、复数）、字符串
	2、不曾使用的常量 编译不报错
	3、定义时若没有设置类型和值，沿用前边
	*/
}

```

### iota

```GO
package main

import "fmt"

func main() {
	// iota，特殊常量，可以认为是一个可以被编译器修改的常量

	/*
		1、后续会自动递增
		2、自增类型默认int
		3、每次出现const关键字时 iota归0
	*/
	const (
		err1 = iota
		err2
		err25
		err3
		err4 = "haha"
		err5
		err6 = iota
		err7 = 100
		err8 = iota
	)
	fmt.Println(err1, err2, err25, err3, err4, err5, err6, err7, err8)
	// 0 1 2 3 haha haha 6 100 8

	const (
		errnew = iota
	)
	fmt.Println(errnew) //0

	const ha = iota
	const ha1 = iota
	fmt.Println(ha, ha1) //0 0
}

```

## 基本数据类型

	+ bool -true/false
 + 数值类型
    + 整数 -(u)int8/(u)int16/(u)int32/(u)int64
    + 浮点数 -float32/float64
    + 复数
    + byte -本质就是uint8，主要适用于存储字符
    + rune -本质是int32，也是字符
 + 字符和string

```go
package main

import "fmt"

func main() {
	var a int8
	var b int16
	var c int32
	var d int64
	fmt.Println(a, b, c, d)
	var e int //动态类型,根据我们操作系统位数来定义
	fmt.Println(e)

	//a=b //报错
	//b=a//报错
	a = int8(b)
	b = int16(a)

	var f1 float32 //最大是3.4e38
	var f2 float64 //最大1.8e308
	fmt.Println(f1, f2)

	var ch byte
	ch = 'a'
	fmt.Println(ch)            //97
	fmt.Printf("c=%c\n", ch+1) //c=b
	ch1 := 97
	fmt.Printf("c=%c\n", ch1) //c=a

	//如果我们处理的字符是英文字符，使用byte，如果有中文，用rune
	var c1 rune = '慕'        //单引号字符，双引号是字符串
	fmt.Printf("c=%c\n", c1) //c=慕

	var name string = "i am tom"
	fmt.Printf("%s\n", name)
}

```

### 类型转换

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// 数值类型相互转换
	var a int = 12
	var b = uint(a)

	var f float32 = 3.14
	var c = int32(f)
	fmt.Println(b, c) //12,3

	var f64 = float64(a)
	fmt.Println(f64) //12

	// go语言类型要求严格
	type IT int
	//var d IT = a//报错
	var d IT = IT(a)
	fmt.Println(d)

	//字符、数字 相互转换
	var istr = "12"
	myint, err := strconv.Atoi(istr) //字符串转数字可能出错
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(myint) //12

	mstr := strconv.Itoa(myint) //数字转字符串不会出错
	fmt.Println(mstr)           //12
}

```

### ParseXxx&FormatXxx

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {

	//一、字符串类型转其他基本类型
	// 1、字符串转换为float
	//这个地方如果写32会按照float32转换，但是函数仍然返回float64
	myf, err := strconv.ParseFloat("3.14", 64)
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(myf) //3.14

	//2、字符串转int
	// 8进制，64位
	parseInt, err := strconv.ParseInt("12", 8, 64)
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseInt) //10,12=8^0*2+8^1*1=10

	// 3、字符串转bool
	parseBool1, err := strconv.ParseBool("true")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool1) //true
	parseBool2, err := strconv.ParseBool("hello")
	if err != nil {
		fmt.Println("convert err!") //convert err!
	}
	fmt.Println(parseBool2) //false,转换失败的话，为默认值false
	parseBool3, err := strconv.ParseBool("1")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool3) //true,"1"->true
	parseBool4, err := strconv.ParseBool("0")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool4) //false，"0"->false
	parseBool5, err := strconv.ParseBool("12")
	if err != nil {
		fmt.Println("convert err!") //convert err!
	}
	fmt.Println(parseBool5) //false,转换失败

	//二、基本类型转字符串
	formatBool := strconv.FormatBool(true)
	fmt.Println(formatBool) //true

	float := strconv.FormatFloat(3.14, 'E', -1, 64)
	fmt.Println(float) //3.14E+00

	//转换为16进制
	formatInt := strconv.FormatInt(42, 16)
	fmt.Println(formatInt) //2a,16^0*10+16^1*2=42

}

```

## 运算符与表达式

+ 算数运算符：+、-、*、/、++ ...
+ 逻辑运算符：||、&&、！
+ 位运算符：&、|、^、>>、<< ...（在底层库中常见，注重性能）
    + ^ 异或，不同为1，相同为0
    + A=60(二进制：0011 1100)，B=13(二进制：0000 1101)
        + A^B=0011 0001
+ 赋值运算符：+=、-=、*= 、/=、%=、&= ...
+ 取地址符：&
+ 指针类型：*

运算符优先级：

<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517125118179.png" alt="image-20240517125118179" style="zoom:60%;" />

## 字符串基本操作

### 字符和字符串处理

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	s := "ha慕课"
	//len方法获取字节长度
	fmt.Println(len(s)) //8
	//在utf8中，英文占一个字节，中文占三个字节
	fmt.Println("%X\n", []byte(s)) //[104 97 230 133 149 232 175 190]

	for i, ch := range s {
		fmt.Printf("(%d %X)", i, ch)
		//（字节索引，Unicode码）
		//(0 68)
		//(1 61)
		//(2 6155) //中文字符占3字节即第2 3 4
		//(5 8BFE) //索引不连续
	}
	fmt.Println()
	// 查看字符串中字符数量
	fmt.Println("Rune count:", utf8.RuneCountInString(s)) //4

	//转换为字节数组
	bytes := []byte(s)
	for len(bytes) > 0 {
		ch, size := utf8.DecodeRune(bytes)
		bytes = bytes[size:]
		fmt.Printf("%c ", ch)
	}
	fmt.Println()

	/*
		转换为rune数组，就能通过索引获取每一个字符
	*/
	for i, ch := range []rune(s) {
		fmt.Printf("(%d %c)", i, ch)
	}
	fmt.Println()
}

```

### 转义符

+ `\n`---换行符

+ `\r`---回车
+ `\t`---水平制表
+ `\\`---`\`
+ `\'`---`'`
+ `\"`---`"`
+ `\?`---`?`

```go
package main

import "fmt"

func main() {
	name1 := "\tgo\"课程\""
	fmt.Println(name1) //	go"课程"

	name2 := `go
			 "课程"`
	fmt.Println(name2) //ln默认加了\r\n
}

```

### 格式化输出

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	uname := "tom"
	out := "hello " + uname
	fmt.Println(out)
	age := 18
	address := "china"
	mobile := "15936178333"
	fmt.Println("用户名:"+uname, "年龄:"+strconv.Itoa(age), "地址:"+address, "电话:"+mobile) //这个性能好
	fmt.Printf("用户名:%s,年龄:%d,地址:%s,电话:%s \r\n", uname, age, address, mobile)        //这个好维护
	userMsg := fmt.Sprintf("用户名:%s,年龄:%d,地址:%s,电话:%s \r\n", uname, age, address, mobile)
	fmt.Println(userMsg)
}

```

### 高性能字符串拼接

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
)

func main() {
	uname := "tom"
	out := "hello " + uname
	fmt.Println(out)
	age := 18

	//通过string的builder进行字符串拼接，高性能
	var builder strings.Builder
	builder.WriteString("用户名")
	builder.WriteString(uname)
	builder.WriteString("用户名")
	builder.WriteString(strconv.Itoa(age))
	re := builder.String()
	fmt.Println(re)

}

```

### 字符串的比较

```go
package main

import "fmt"

func main() {
	a := "hello"
	b := "hello"
	c := "bello"
	fmt.Println(a == b) //true
	fmt.Println(a > c)//true，因为h的assic码比b的assic码大
	
}

```

### 字符串操作常用方法

```go
package main

import (
	"fmt"
	"strings"
)

func main() {

	//strings常用方法
	name := "haha攻城狮"
	fmt.Println(strings.Contains(name, "狮"))              //true
	fmt.Println(len([]rune(name)))                        //7
	fmt.Println(strings.Count(name, "h"))                 //2
	fmt.Println(strings.Split(name, "攻城"))                //[haha 狮]
	fmt.Println(strings.HasPrefix(name, "ha"))            //true，作为前缀
	fmt.Println(strings.HasSuffix(name, "攻城狮"))           //true,作为后缀
	fmt.Println(strings.Index(name, "城"))                 //7，字符串存在则返回第一个字节位置
	fmt.Println(strings.IndexRune(name, []rune(name)[5])) //7,rune存在则返回第一个字节位置
	fmt.Println(strings.Replace(name, "ha", "hello", -1)) //hellohello攻城狮
	//-1表示全替换，1表示替换前一个，2表示替换前两个
	fmt.Println(strings.Replace(name, "ha", "hello", 1)) //hellohello攻城狮
	fmt.Println(strings.ToLower("GO"))                   //go
	fmt.Println(strings.Trim("##he#llo#", "#"))         //he#llo

}

```

## 条件判断和循环语句

+ if条件判断
+ for循环、break、continue、for range
+ goto
+ switch

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	/*
		1、if条件判断
	*/
	a := 18
	country := "china"
	if a < 18 {
		fmt.Println("未成年~")
	} else if a == 18 && country == "china" {
		fmt.Println("刚满18岁~")
	} else {
	}

	/*
		2、for循环，go不提供while循环
	*/
	//这仨都不是必须的
	for i := 0; i < 10; i++ {
		fmt.Println(i) //打印0~9
	}
	//这种写法 无限循环
	//for {
	//	fmt.Println("hi~")
	//}

	var j int
	for j <= 3 {
		fmt.Println(j)
		j++
	}

	/*
		3、for循环打印99乘法表
	*/
	for a := 1; a <= 9; a++ {
		for b := 1; b <= a; b++ {
			fmt.Printf("%dx%d=%d ", a, b, a*b)
		}
		fmt.Println()
	}

	/*
		4、for range的循环用法
		主要是对字符串、数组、切片、map、channel
	*/
	name := "hi耶,go"
	//字符串的索引（key）、字符串对应的索引的字符值的拷贝（value）
	for key, value := range name {
		fmt.Println(key, value)
		fmt.Printf("%d,%c \r\n", key, value)
		//0 104
		//0,h
		//1 105
		//1,i
		//2 32822
		//2,耶
		//5 44
		//5,,
		//6 103
		//6,g
		//7 111
		//7,o
	}
	//其他写法
	for _, value := range name {
		fmt.Println(value)
	}
	// 不写key，返回索引
	for index := range name {
		fmt.Print(index)
		//打印对应index的字符
		fmt.Printf("%c ", name[index]) //只针对英文

		//0h 1i 2è 5, 6g 7o
	}
	fmt.Println()

	/*
		5、for循环的 break & continue
	*/
	test := 0
	for {
		time.Sleep(1 * time.Second)
		test++
		if test == 3 {
			continue
		}
		fmt.Print(test, " ") // 1 2 4 5
		if test == 5 {
			break
		}
	}

	/*
		6、goto语句
			很少用，可读性差，不建议用
			使用场景多用于错误处理，出错统一跳转到相应标签处，统一处理
	*/
	for x := 0; x < 5; x++ {
		for y := 0; y < 5; y++ {
			if j == 2 {
				//假设我们想在这结束两层循环，break只能结束一层
				goto over
			}
		}
	}
over:
	fmt.Println("over...")

	/*
		7、switch语句
			代码更可读、执行效率更高
	*/
	day := "星期三"
	switch day {
	case "星期一":
		fmt.Println("Monday...")
	case "星期二":
		fmt.Println("Tuesday...")
	case "星期三":
		fmt.Println("Wednesday...")
	case "星期四":
		fmt.Println("Thursday...")
	default:
		fmt.Println("other...")
	}

	score := 60
	switch {
	case score < 60:
		fmt.Println("不及格。。。")
	case score >= 60 && score < 80:
		fmt.Println("良好...")
	case score >= 80:
		fmt.Println("优秀")
	}
	
	switch score {
	case 60, 70, 80:
		fmt.Println("恰好是60 70 80.。。")
	default:
		fmt.Println("other...")
	}
}

```

# go集合

go集合类型的数据结构

+ 数组
+ 切片slice --重要
+ map  --重要
+ list

## 数组

```go
package main

import "fmt"

func main() {
	//数组
	/*
		1、数组定义
	*/
	var courses1 [3]string
	//[3]string为只有三个元素的数组类型,和[4]string不是一种数据类型！！！
	//[]string和[3]string不是一种类型！！！，[]string为切片
	var courses2 [4]string

	//%T表示输出类型
	fmt.Printf("%T\r\n", courses1)
	fmt.Printf("%T\n", courses2)
	//courses2=courses1 //报错，类型不匹配

	/*
		2、数组赋值
	*/
	courses1[0] = "go"
	courses1[1] = "python"
	courses1[2] = "java"
	fmt.Println(courses1)

	/*
		3、数组遍历
	*/
	for _, course := range courses1 {
		fmt.Println(course)
	}
	for i := 0; i < len(courses1); i++ {
		fmt.Println(courses1[i])
	}

	/*
		4、数组初始化
	*/
	var courses3 [3]string = [3]string{"go", "python", "java"} //这里的定义类型可以省略
	fmt.Println(courses3)                                      //[go python java]
	var courses4 [4]string = [4]string{2: "gin"}
	fmt.Println(courses4) //[  gin ]
	courses5 := [...]string{"go", "java"}
	fmt.Println(courses5)          //[go java]
	fmt.Printf("%T\r\n", courses5) //[2]string

	/*
		5、数组间的比较
	*/
	//if courses4==courses5 {}//报错，无法比较，因为类型不匹配
	if courses1 == courses3 { //可以比较，类型匹配
		//会比对数组每一个元素
		fmt.Println("equal...")
	}

	/*
		6、多维数组定义赋值
	*/
	var courseinfo [3][4]string //3行4列
	courseinfo[0] = [4]string{"go", "1h", "tom", "go体系"}
	//也可以这样赋值
	//courseinfo[0][0]="go"
	//courseinfo[0][1]="python"
	courseinfo[1] = [4]string{"grpc", "2h", "tom", "grpc框架"}
	courseinfo[2] = [4]string{"gin", "1.5h", "tom", "gin高级开发"}

	/*
		7、多维数组遍历
	*/
	fmt.Println(len(courseinfo))//3
	for i := 0; i < len(courseinfo); i++ {
		for j := 0; j < len(courseinfo[i]); j++ {
			fmt.Print(courseinfo[i][j], " ")
		}
		fmt.Println()
	}
	for _, course := range courseinfo {
		for _, value := range course {
			fmt.Print(value, " ")
		}
		fmt.Println()
	}

}

```

## 切片

用法上和数组类似，底层也是数组

### slice 的基本使用

```go
package main

import "fmt"

func main() {

	/*
		1、切片的定义和添加元素
	*/
	var courses []string
	fmt.Printf("%T\n", courses)     //[]string
	courses = append(courses, "go") //接受类型和放置类型要一样！！！，都是courses
	fmt.Printf("%T\n", courses)     //[]string
	fmt.Println(courses)            //[go]
	fmt.Println(courses[0])         //go

	/*
		2、切片初始化
			- 从数组直接创建
			- 使用string{}
			- make
	*/
	allCourses := [5]string{"go", "grpc", "gin", "mysql", "elasticsearch"}
	fmt.Println(allCourses) //[go grpc gin mysql elasticsearch]
	// 第一种
	courseSlice := allCourses[0:2] //[go grpc]，左闭右开[)
	fmt.Println(courseSlice)
	fmt.Printf("%T\n", courseSlice)
	// 第二种
	coursesSlice1 := []string{"go", "grpc", "gin", "mysql", "elasticsearch"}
	fmt.Println(coursesSlice1)        //[go grpc gin mysql elasticsearch]
	fmt.Printf("%T\n", coursesSlice1) //[]string
	//第三种
	courseSlice2 := make([]string, 3) //先预分配空间3
	courseSlice2[0] = "go"
	courseSlice2[1] = "grpc"
	courseSlice2[2] = "gin"
	fmt.Println(courseSlice2) //[go grpc gin]

	var courseSlice3 []string //没有预先分配空间，只能使用append添加
	//courseSlice3[0] = "go"    //运行报错，index out of range [0] with length 0
	courseSlice3 = append(courseSlice3, "go")

	/*
		3、访问切片的元素
			- 访问单个，跟数组一样
			- 访问多个
	*/
	courseSlice4 := []string{"go", "grpc", "gin", "mysql", "elasticsearch"}
	fmt.Println(courseSlice4[1])          //grpc
	fmt.Println(courseSlice4[:])          //[go grpc gin mysql elasticsearch]
	fmt.Println(courseSlice4[2:])         //[gin mysql elasticsearch]
	fmt.Println(courseSlice4[:3])         //[go grpc gin]
	fmt.Printf("%T\n", courseSlice4[1:2]) //[]string

	/*
		4、slice for循环
			- 跟数组一样
	*/

	/*
		5、slice 添加
	*/
	courseSlice5 := []string{"go", "grpc"}
	courseSlice5 = append(courseSlice5, "gin", "mysql", "elasticsearch")
	fmt.Println(courseSlice5) //[go grpc gin mysql elasticsearch]
	courseSlice6 := []string{"go1", "grpc1"}
	courseSlice6 = append(courseSlice6, courseSlice5...)
	fmt.Println(courseSlice6) //[go1 grpc1 go grpc gin mysql elasticsearch]
	courseSlice6 = append(courseSlice6, courseSlice5[1:3]...)
	fmt.Println(courseSlice6) //[go1 grpc1 go grpc gin mysql elasticsearch grpc gin]

	/*
		6、slice 删除元素
			- 左右slice拼接，重新生成slice
	*/
	courseSlice7 := []string{"go", "grpc", "gin", "mysql", "elasticsearch"}
	//删除 gin
	myslice := append(courseSlice7[0:2], courseSlice7[3:]...)
	fmt.Println(myslice) //[go grpc mysql elasticsearch]
	// 删除mysql、elasticsearch
	myslice1 := courseSlice7[:3]
	fmt.Println(myslice1) //[go grpc mysql]

	/*
		7、复制 slice
	*/
	coursesSliceCopy := courseSlice7 //本质没有拷贝，只是指向同一
	coursesSliceCopy1 := courseSlice7[:]
	fmt.Println(coursesSliceCopy, " ", coursesSliceCopy1)

	var coursesSliceCopy2 = make([]string, len(courseSlice7))
	copy(coursesSliceCopy2, courseSlice7)
	fmt.Println(coursesSliceCopy2) //[go grpc mysql elasticsearch elasticsearch]
	courseSlice7[0] = "hello~"
	fmt.Println(coursesSliceCopy, coursesSliceCopy1, coursesSliceCopy2) //输出为下面3行
	//[hello~ grpc mysql elasticsearch elasticsearch]
	//[hello~ grpc mysql elasticsearch elasticsearch]
	//[go grpc mysql elasticsearch elasticsearch]

	coursesSliceCopy4 := courseSlice7[:3]
	fmt.Println(coursesSliceCopy4) //[hello~ grpc mysql]
	courseSlice7[1] = "test"
	fmt.Println(coursesSliceCopy4) //[hello~ test mysql]

}

```

### slice底层原理

+ 现象引入

```go
package main

import (
	"fmt"
	"strconv"
)

func printSlice(data []string) {
	data[0] = "java"
	for i := 0; i < 10; i++ {
		data = append(data, strconv.Itoa(i))
	}
	fmt.Println(data)
}

func main() {
	//slice 底层原理

	//对于前边内容的一个补充
	fmt.Printf("%T, %T\n", [...]string{}, []string{}) //[0]string, []string

	/*
		go的slice在函数参数传递的时候是值传递，
		但是效果又呈现出了引用的效果（不完全是）
	*/
	//现象引入：
	course := []string{"go", "grpc", "gin"}
	printSlice(course)  ////[java grpc gin 0 1 2 3 4 5 6 7 8 9]
	fmt.Println(course) //[java grpc gin]

}

```

+ slice原理

```go

// slice 结构体
type slice struct {
	array unsafe.Pointer //用来存储实际数据的数组指针，指向一块连续的内存
	len   int            //切片中元素数量
	cap   int            //array数组的长度、容量
}
//在go语言中，结构体传递为值传递，会拷贝一份

```

`myslice:=[]string{"go","grpc","gin"}`为语法糖，在编译时会转换成：

```
myslice := slice{
	array指向数组
	len:3
	cap:3
}
```

在使用make方法时 `myslice:=make([]string,5,10)`，在底层表示为，len：5，cap：10，如图。<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517235239217.png" alt="image-20240517235239217" style="zoom: 67%;" />

当我们使用append方法时，当cap不够会扩容，生成新数组并将原数组拷贝过来，非常耗时。

有可能一开始我们自己初始化一个数组，然后选取1-4， 3个元素。

即下图。<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517235438675.png" alt="image-20240517235438675" style="zoom:67%;" />

当我们函数参数传递时，会拷贝结构体：![image-20240517235810710](./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517235810710.png)

虽然说是值传递，但是指针指向同一个底层数组，所以会出现引用传递的效果。

也可能两个slice通过同一个数组（长度为10）生成，切的位置不一样：![image-20240518000049611](./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240518000049611.png)

这样指向的也是同一个数组，前者cap=9，后者cap=8，如果后者发生扩容，就指向两个不同的数组了![image-20240518000736413](./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240518000736413.png)

此时再修改数据就互不影响了；这也就是为啥append的第一个参数要和返回值要一致，因为是值传递且有可能扩容。

```go
package main

import (
	"fmt"
	"strconv"
)

func printSlice(data []string) {
	data[0] = "java"
	for i := 0; i < 10; i++ {
		data = append(data, strconv.Itoa(i))
	}
	fmt.Println(data)
}

func main() {
	//slice 底层原理

	//对于前边内容的一个补充
	fmt.Printf("%T, %T\n", [...]string{}, []string{}) //[0]string, []string

	/*
		go的slice在函数参数传递的时候是值传递，
		但是效果又呈现出了引用的效果（不完全是）
	*/
	//现象引入：
	course := []string{"go", "grpc", "gin"}
	printSlice(course)  ////[java grpc gin 0 1 2 3 4 5 6 7 8 9]
	fmt.Println(course) //[java grpc gin]

	/*
		type slice struct {
			array unsafe.Pointer //用来存储实际数据的数组指针，指向一块连续的内存
			len   int            //切片中元素数量
			cap   int            //array数组的长度
		}
	*/

	// 原理：

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	s1 := data[3:6]
	s2 := data[2:7]
	s2[1] = 22
	fmt.Println(s1)               //[22 5 6]
	fmt.Println(s2)               //[3 22 5 6 7]
	fmt.Println(len(s1), cap(s1)) //3 7
	fmt.Println(len(s2), cap(s2)) //5,8

	s2 = append(s2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 1, 1)
	s2[1] = 33
	fmt.Println(s1)               //[22 5 6]，扩容后就不影响了
	fmt.Println(s2)               //[3 33 5 6 7 1 2 3 4 5 6 7 8 9 1 1 1]
	fmt.Println(len(s1), cap(s1)) //3 7
	fmt.Println(len(s2), cap(s2)) //17 18

    //查看扩容机制
	var data1 []int
	for i := 0; i < 2000; i++ {
		data1 = append(data1, i)
		fmt.Printf("len: %d, cap: %d\n", len(data1), cap(data1))
	}
}

```



## map

