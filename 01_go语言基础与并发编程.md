

[TOC]

# goland快捷键

> 设置-->按键映射-->安装Eclipse快捷键插件

| 快捷键  | 作用 |
| --- | --- |
| CTRL+D |  删除一行代码    |
| ALT+<- | 退出代码     |
|     ALT+->   |     进入代码         |
|        |              |

# go语言基础

## HelloWorld

```go
package main

import "fmt"

func main() {
	fmt.Println("hello world")
}

```

> 编译：go build .\hello.go
>
> 编译运行：go run .\hello.go 

要设置package main并有main函数，这个go文件才能编译运行

同一个目录中的所有go文件只能有一个main函数，否则报错，goland不报错是因为<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240516224259107.png" alt="image-20240516224259107" style="zoom:50%;" />



## 变量

### 变量定义

```go
package main

import "fmt"

// 定义在main函数外为全局变量
// 这里定义的全局变量没有用到不会报错
// var name = "tom"
// var ok bool //布尔类型默认值false
// 上面两行代码通常这样写：
var (
	name = "tom"
	ok   bool
)

//简洁变量定义不能作用于全局变量
//age:=1 //报错

func main() {
	//go是静态语言
	/*
		1、变量先定义后使用
		2、变量必须有类型
		3、类型定义后不能改变
		4、同一作用域 变量名不能冲突
		5、简洁变量定义不能作用于全局变量
		6、变量有默认值
	*/

	//变相定义方式：
	//var age int=1 //类型定义在后边
	//var age=1		//int可省略，自动类型推断
	age := 100 //:=为赋值符号，可以省略var
	//go语言中局部变量定义后不使用会报错
	fmt.Println(age)

	//多变量定义
	//var user1, user2, user3 string //默认为空字符串
	var user1, user2, user3 = "tom1", 1, "tom3"
	fmt.Println(user1, user2, user3)

}

```

### 匿名变量

```go
package main

import "fmt"

// 定义一个函数
func a() (int, bool) {
	return 0, false
}

func main() {
	// 匿名变量，定义后但是不想使用
	var _ int
	//比如这里的r1我们不关心，我们只关心返回ok值有没有成功
	//r1, ok := a()
	_, ok := a() //改成匿名变量接收
	if ok {
		//如果不使用 _ 匿名变量接收，那我们必须要使用下r1变量，否则报错
		//fmt.Println(r1)
	}

}

```

### 变量作用域

```go
package main

import "fmt"

func main() {
	/*
		变量的作用域为定义的{}中
	*/

	{
		name := "hah"
		fmt.Println(name) //hah
	}
	//fmt.Println(name)//访问不到

	var age = 100
	if age == 100 {
		age := 1
		fmt.Println(age) //1
	}
	fmt.Println(age) //100
}

```

## 常量

### 定义

```go
package main

import "fmt"

func main() {
	//显式定义常量
	const PI float64 = 3.1415926
	//隐式定义
	const PI2 = 3.1415926

	//命名：大写，单词间使用_连接

	//可以一组常量定义
	const (
		UNKNOW = 1
		FEMALE = 2
		MALE   = 3
	)

	const (
		x int = 16
		y
		s = "abc"
		z
	)
	fmt.Println(x, y, s, z) //16 16 abc abc
	/* 默认规则：
	1、常量类型定义只支持 bool、数值（整数、浮点数、复数）、字符串
	2、不曾使用的常量 编译不报错
	3、定义时若没有设置类型和值，沿用前边
	*/
}

```

### iota

```GO
package main

import "fmt"

func main() {
	// iota，特殊常量，可以认为是一个可以被编译器修改的常量

	/*
		1、后续会自动递增
		2、自增类型默认int
		3、每次出现const关键字时 iota归0
	*/
	const (
		err1 = iota
		err2
		err25
		err3
		err4 = "haha"
		err5
		err6 = iota
		err7 = 100
		err8 = iota
	)
	fmt.Println(err1, err2, err25, err3, err4, err5, err6, err7, err8)
	// 0 1 2 3 haha haha 6 100 8

	const (
		errnew = iota
	)
	fmt.Println(errnew) //0

	const ha = iota
	const ha1 = iota
	fmt.Println(ha, ha1) //0 0
}

```

## 基本数据类型

 + bool -true/false
 + 数值类型
    + 整数 -(u)int8/(u)int16/(u)int32/(u)int64
    + 浮点数 -float32/float64
    + 复数
    + byte -本质就是uint8，主要适用于存储字符
    + rune -本质是int32，也是字符
 + 字符和string

```go
package main

import "fmt"

func main() {
	var a int8
	var b int16
	var c int32
	var d int64
	fmt.Println(a, b, c, d)
	var e int //动态类型,根据我们操作系统位数来定义
	fmt.Println(e)

	//a=b //报错
	//b=a//报错
	a = int8(b)
	b = int16(a)

	var f1 float32 //最大是3.4e38
	var f2 float64 //最大1.8e308
	fmt.Println(f1, f2)

	var ch byte
	ch = 'a'
	fmt.Println(ch)            //97
	fmt.Printf("c=%c\n", ch+1) //c=b
	ch1 := 97
	fmt.Printf("c=%c\n", ch1) //c=a

	//如果我们处理的字符是英文字符，使用byte，如果有中文，用rune
	var c1 rune = '慕'        //单引号字符，双引号是字符串
	fmt.Printf("c=%c\n", c1) //c=慕

	var name string = "i am tom"
	fmt.Printf("%s\n", name)
}

```

### 类型转换

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// 数值类型相互转换
	var a int = 12
	var b = uint(a)

	var f float32 = 3.14
	var c = int32(f)
	fmt.Println(b, c) //12,3

	var f64 = float64(a)
	fmt.Println(f64) //12

	// go语言类型要求严格
	type IT int
	//var d IT = a//报错
	var d IT = IT(a)
	fmt.Println(d)

	//字符、数字 相互转换
	var istr = "12"
	myint, err := strconv.Atoi(istr) //字符串转数字可能出错
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(myint) //12

	mstr := strconv.Itoa(myint) //数字转字符串不会出错
	fmt.Println(mstr)           //12
}

```

### ParseXxx&FormatXxx

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {

	//一、字符串类型转其他基本类型
	// 1、字符串转换为float
	//这个地方如果写32会按照float32转换，但是函数仍然返回float64
	myf, err := strconv.ParseFloat("3.14", 64)
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(myf) //3.14

	//2、字符串转int
	// 8进制，64位
	parseInt, err := strconv.ParseInt("12", 8, 64)
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseInt) //10,12=8^0*2+8^1*1=10

	// 3、字符串转bool
	parseBool1, err := strconv.ParseBool("true")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool1) //true
	parseBool2, err := strconv.ParseBool("hello")
	if err != nil {
		fmt.Println("convert err!") //convert err!
	}
	fmt.Println(parseBool2) //false,转换失败的话，为默认值false
	parseBool3, err := strconv.ParseBool("1")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool3) //true,"1"->true
	parseBool4, err := strconv.ParseBool("0")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool4) //false，"0"->false
	parseBool5, err := strconv.ParseBool("12")
	if err != nil {
		fmt.Println("convert err!") //convert err!
	}
	fmt.Println(parseBool5) //false,转换失败

	//二、基本类型转字符串
	formatBool := strconv.FormatBool(true)
	fmt.Println(formatBool) //true

	float := strconv.FormatFloat(3.14, 'E', -1, 64)
	fmt.Println(float) //3.14E+00

	//转换为16进制
	formatInt := strconv.FormatInt(42, 16)
	fmt.Println(formatInt) //2a,16^0*10+16^1*2=42

}

```

## 运算符与表达式

+ 算数运算符：+、-、*、/、++ ...
+ 逻辑运算符：||、&&、！
+ 位运算符：&、|、^、>>、<< ...（在底层库中常见，注重性能）
    + ^ 异或，不同为1，相同为0
    + A=60(二进制：0011 1100)，B=13(二进制：0000 1101)
        + A^B=0011 0001
+ 赋值运算符：+=、-=、*= 、/=、%=、&= ...
+ 取地址符：&
+ 指针类型：*

运算符优先级：

<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517125118179.png" alt="image-20240517125118179" style="zoom:60%;" />

## 字符串基本操作

### 字符和字符串处理

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	s := "ha慕课"
	//len方法获取字节长度
	fmt.Println(len(s)) //8
	//在utf8中，英文占一个字节，中文占三个字节
	fmt.Println("%X\n", []byte(s)) //[104 97 230 133 149 232 175 190]

	for i, ch := range s {
		fmt.Printf("(%d %X)", i, ch)
		//（字节索引，Unicode码）
		//(0 68)
		//(1 61)
		//(2 6155) //中文字符占3字节即第2 3 4
		//(5 8BFE) //索引不连续
	}
	fmt.Println()
	// 查看字符串中字符数量
	fmt.Println("Rune count:", utf8.RuneCountInString(s)) //4

	//转换为字节数组
	bytes := []byte(s)
	for len(bytes) > 0 {
		ch, size := utf8.DecodeRune(bytes)
		bytes = bytes[size:]
		fmt.Printf("%c ", ch)
	}
	fmt.Println()

	/*
		转换为rune数组，就能通过索引获取每一个字符
	*/
	for i, ch := range []rune(s) {
		fmt.Printf("(%d %c)", i, ch)
	}
	fmt.Println()
}

```

### 转义符

+ `\n`---换行符

+ `\r`---回车
+ `\t`---水平制表
+ `\\`---`\`
+ `\'`---`'`
+ `\"`---`"`
+ `\?`---`?`

```go
package main

import "fmt"

func main() {
	name1 := "\tgo\"课程\""
	fmt.Println(name1) //	go"课程"

	name2 := `go
			 "课程"`
	fmt.Println(name2) //ln默认加了\r\n
}

```

### 格式化输出

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	uname := "tom"
	out := "hello " + uname
	fmt.Println(out)
	age := 18
	address := "china"
	mobile := "15936178333"
	fmt.Println("用户名:"+uname, "年龄:"+strconv.Itoa(age), "地址:"+address, "电话:"+mobile) //这个性能好
	fmt.Printf("用户名:%s,年龄:%d,地址:%s,电话:%s \r\n", uname, age, address, mobile)        //这个好维护
	userMsg := fmt.Sprintf("用户名:%s,年龄:%d,地址:%s,电话:%s \r\n", uname, age, address, mobile)
	fmt.Println(userMsg)
}

```

### 高性能字符串拼接

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
)

func main() {
	uname := "tom"
	out := "hello " + uname
	fmt.Println(out)
	age := 18

	//通过string的builder进行字符串拼接，高性能
	var builder strings.Builder
	builder.WriteString("用户名")
	builder.WriteString(uname)
	builder.WriteString("用户名")
	builder.WriteString(strconv.Itoa(age))
	re := builder.String()
	fmt.Println(re)

}

```

### 字符串的比较

```go
package main

import "fmt"

func main() {
	a := "hello"
	b := "hello"
	c := "bello"
	fmt.Println(a == b) //true
	fmt.Println(a > c)//true，因为h的assic码比b的assic码大
	
}

```

### 字符串操作常用方法

```go
package main

import (
	"fmt"
	"strings"
)

func main() {

	//strings常用方法
	name := "haha攻城狮"
	fmt.Println(strings.Contains(name, "狮"))              //true
	fmt.Println(len([]rune(name)))                        //7
	fmt.Println(strings.Count(name, "h"))                 //2
	fmt.Println(strings.Split(name, "攻城"))                //[haha 狮]
	fmt.Println(strings.HasPrefix(name, "ha"))            //true，作为前缀
	fmt.Println(strings.HasSuffix(name, "攻城狮"))           //true,作为后缀
	fmt.Println(strings.Index(name, "城"))                 //7，字符串存在则返回第一个字节位置
	fmt.Println(strings.IndexRune(name, []rune(name)[5])) //7,rune存在则返回第一个字节位置
	fmt.Println(strings.Replace(name, "ha", "hello", -1)) //hellohello攻城狮
	//-1表示全替换，1表示替换前一个，2表示替换前两个
	fmt.Println(strings.Replace(name, "ha", "hello", 1)) //hellohello攻城狮
	fmt.Println(strings.ToLower("GO"))                   //go
	fmt.Println(strings.Trim("##he#llo#", "#"))         //he#llo

}

```

## 条件判断和循环语句

+ if条件判断
+ for循环、break、continue、for range
+ goto
+ switch

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	/*
		1、if条件判断
	*/
	a := 18
	country := "china"
	if a < 18 {
		fmt.Println("未成年~")
	} else if a == 18 && country == "china" {
		fmt.Println("刚满18岁~")
	} else {
	}

	/*
		2、for循环，go不提供while循环
	*/
	//这仨都不是必须的
	for i := 0; i < 10; i++ {
		fmt.Println(i) //打印0~9
	}
	//这种写法 无限循环
	//for {
	//	fmt.Println("hi~")
	//}

	var j int
	for j <= 3 {
		fmt.Println(j)
		j++
	}

	/*
		3、for循环打印99乘法表
	*/
	for a := 1; a <= 9; a++ {
		for b := 1; b <= a; b++ {
			fmt.Printf("%dx%d=%d ", a, b, a*b)
		}
		fmt.Println()
	}

	/*
		4、for range的循环用法
		主要是对字符串、数组、切片、map、channel
	*/
	name := "hi耶,go"
	//字符串的索引（key）、字符串对应的索引的字符值的拷贝（value）
	for key, value := range name {
		fmt.Println(key, value)
		fmt.Printf("%d,%c \r\n", key, value)
		//0 104
		//0,h
		//1 105
		//1,i
		//2 32822
		//2,耶
		//5 44
		//5,,
		//6 103
		//6,g
		//7 111
		//7,o
	}
	//其他写法
	for _, value := range name {
		fmt.Println(value)
	}
	// 不写key，返回索引
	for index := range name {
		fmt.Print(index)
		//打印对应index的字符
		fmt.Printf("%c ", name[index]) //只针对英文

		//0h 1i 2è 5, 6g 7o
	}
	fmt.Println()

	/*
		5、for循环的 break & continue
	*/
	test := 0
	for {
		time.Sleep(1 * time.Second)
		test++
		if test == 3 {
			continue
		}
		fmt.Print(test, " ") // 1 2 4 5
		if test == 5 {
			break
		}
	}

	/*
		6、goto语句
			很少用，可读性差，不建议用
			使用场景多用于错误处理，出错统一跳转到相应标签处，统一处理
	*/
	for x := 0; x < 5; x++ {
		for y := 0; y < 5; y++ {
			if j == 2 {
				//假设我们想在这结束两层循环，break只能结束一层
				goto over
			}
		}
	}
over:
	fmt.Println("over...")

	/*
		7、switch语句
			代码更可读、执行效率更高
	*/
	day := "星期三"
	switch day {
	case "星期一":
		fmt.Println("Monday...")
	case "星期二":
		fmt.Println("Tuesday...")
	case "星期三":
		fmt.Println("Wednesday...")
	case "星期四":
		fmt.Println("Thursday...")
	default:
		fmt.Println("other...")
	}

	score := 60
	switch {
	case score < 60:
		fmt.Println("不及格。。。")
	case score >= 60 && score < 80:
		fmt.Println("良好...")
	case score >= 80:
		fmt.Println("优秀")
	}
	
	switch score {
	case 60, 70, 80:
		fmt.Println("恰好是60 70 80.。。")
	default:
		fmt.Println("other...")
	}
}

```

# go集合

go集合类型的数据结构

+ 数组
    + 不同长度的数组类型不一样

+ 切片slice --重要
    + 性能高
    + 动态数组
    + 方便，常用

+ map  --重要
+ list

## 数组

```go
package main

import "fmt"

func main() {
	//数组
	/*
		1、数组定义
	*/
	var courses1 [3]string
	//[3]string为只有三个元素的数组类型,和[4]string不是一种数据类型！！！
	//[]string和[3]string不是一种类型！！！，[]string为切片
	var courses2 [4]string

	//%T表示输出类型
	fmt.Printf("%T\r\n", courses1)
	fmt.Printf("%T\n", courses2)
	//courses2=courses1 //报错，类型不匹配

	/*
		2、数组赋值
	*/
	courses1[0] = "go"
	courses1[1] = "python"
	courses1[2] = "java"
	fmt.Println(courses1)

	/*
		3、数组遍历
	*/
	for _, course := range courses1 {
		fmt.Println(course)
	}
	for i := 0; i < len(courses1); i++ {
		fmt.Println(courses1[i])
	}

	/*
		4、数组初始化
	*/
	var courses3 [3]string = [3]string{"go", "python", "java"} //这里的定义类型可以省略
	fmt.Println(courses3)                                      //[go python java]
	var courses4 [4]string = [4]string{2: "gin"}
	fmt.Println(courses4) //[  gin ]
	courses5 := [...]string{"go", "java"}
	fmt.Println(courses5)          //[go java]
	fmt.Printf("%T\r\n", courses5) //[2]string

	/*
		5、数组间的比较
	*/
	//if courses4==courses5 {}//报错，无法比较，因为类型不匹配
	if courses1 == courses3 { //可以比较，类型匹配
		//会比对数组每一个元素
		fmt.Println("equal...")
	}

	/*
		6、多维数组定义赋值
	*/
	var courseinfo [3][4]string //3行4列
	courseinfo[0] = [4]string{"go", "1h", "tom", "go体系"}
	//也可以这样赋值
	//courseinfo[0][0]="go"
	//courseinfo[0][1]="python"
	courseinfo[1] = [4]string{"grpc", "2h", "tom", "grpc框架"}
	courseinfo[2] = [4]string{"gin", "1.5h", "tom", "gin高级开发"}

	/*
		7、多维数组遍历
	*/
	fmt.Println(len(courseinfo))//3
	for i := 0; i < len(courseinfo); i++ {
		for j := 0; j < len(courseinfo[i]); j++ {
			fmt.Print(courseinfo[i][j], " ")
		}
		fmt.Println()
	}
	for _, course := range courseinfo {
		for _, value := range course {
			fmt.Print(value, " ")
		}
		fmt.Println()
	}

}

```

## 切片

用法上和数组类似，底层也是数组

### slice 的基本使用

```go
package main

import "fmt"

func main() {

	/*
		1、切片的定义和添加元素
	*/
	var courses []string
	fmt.Printf("%T\n", courses)     //[]string
	courses = append(courses, "go") //接受类型和放置类型要一样！！！，都是courses
	fmt.Printf("%T\n", courses)     //[]string
	fmt.Println(courses)            //[go]
	fmt.Println(courses[0])         //go

	/*
		2、切片初始化
			- 从数组直接创建
			- 使用string{}
			- make
	*/
	allCourses := [5]string{"go", "grpc", "gin", "mysql", "elasticsearch"}
	fmt.Println(allCourses) //[go grpc gin mysql elasticsearch]
	// 第一种
	courseSlice := allCourses[0:2] //[go grpc]，左闭右开[)
	fmt.Println(courseSlice)
	fmt.Printf("%T\n", courseSlice)
	// 第二种
	coursesSlice1 := []string{"go", "grpc", "gin", "mysql", "elasticsearch"}
	fmt.Println(coursesSlice1)        //[go grpc gin mysql elasticsearch]
	fmt.Printf("%T\n", coursesSlice1) //[]string
	//第三种
	courseSlice2 := make([]string, 3) //先预分配空间3
	courseSlice2[0] = "go"
	courseSlice2[1] = "grpc"
	courseSlice2[2] = "gin"
	fmt.Println(courseSlice2) //[go grpc gin]

	var courseSlice3 []string //没有预先分配空间，只能使用append添加
	//courseSlice3[0] = "go"    //运行报错，index out of range [0] with length 0
	courseSlice3 = append(courseSlice3, "go")

	/*
		3、访问切片的元素
			- 访问单个，跟数组一样
			- 访问多个
	*/
	courseSlice4 := []string{"go", "grpc", "gin", "mysql", "elasticsearch"}
	fmt.Println(courseSlice4[1])          //grpc
	fmt.Println(courseSlice4[:])          //[go grpc gin mysql elasticsearch]
	fmt.Println(courseSlice4[2:])         //[gin mysql elasticsearch]
	fmt.Println(courseSlice4[:3])         //[go grpc gin]
	fmt.Printf("%T\n", courseSlice4[1:2]) //[]string

	/*
		4、slice for循环
			- 跟数组一样
	*/

	/*
		5、slice 添加
	*/
	courseSlice5 := []string{"go", "grpc"}
	courseSlice5 = append(courseSlice5, "gin", "mysql", "elasticsearch")
	fmt.Println(courseSlice5) //[go grpc gin mysql elasticsearch]
	courseSlice6 := []string{"go1", "grpc1"}
	courseSlice6 = append(courseSlice6, courseSlice5...)
	fmt.Println(courseSlice6) //[go1 grpc1 go grpc gin mysql elasticsearch]
	courseSlice6 = append(courseSlice6, courseSlice5[1:3]...)
	fmt.Println(courseSlice6) //[go1 grpc1 go grpc gin mysql elasticsearch grpc gin]

	/*
		6、slice 删除元素
			- 左右slice拼接，重新生成slice
	*/
	courseSlice7 := []string{"go", "grpc", "gin", "mysql", "elasticsearch"}
	//删除 gin
	myslice := append(courseSlice7[0:2], courseSlice7[3:]...)
	fmt.Println(myslice) //[go grpc mysql elasticsearch]
	// 删除mysql、elasticsearch
	myslice1 := courseSlice7[:3]
	fmt.Println(myslice1) //[go grpc mysql]

	/*
		7、复制 slice
	*/
	coursesSliceCopy := courseSlice7 //本质没有拷贝，只是指向同一
	coursesSliceCopy1 := courseSlice7[:]
	fmt.Println(coursesSliceCopy, " ", coursesSliceCopy1)

	var coursesSliceCopy2 = make([]string, len(courseSlice7))
	copy(coursesSliceCopy2, courseSlice7)
	fmt.Println(coursesSliceCopy2) //[go grpc mysql elasticsearch elasticsearch]
	courseSlice7[0] = "hello~"
	fmt.Println(coursesSliceCopy, coursesSliceCopy1, coursesSliceCopy2) //输出为下面3行
	//[hello~ grpc mysql elasticsearch elasticsearch]
	//[hello~ grpc mysql elasticsearch elasticsearch]
	//[go grpc mysql elasticsearch elasticsearch]

	coursesSliceCopy4 := courseSlice7[:3]
	fmt.Println(coursesSliceCopy4) //[hello~ grpc mysql]
	courseSlice7[1] = "test"
	fmt.Println(coursesSliceCopy4) //[hello~ test mysql]

}

```

### slice底层原理

+ 现象引入

```go
package main

import (
	"fmt"
	"strconv"
)

func printSlice(data []string) {
	data[0] = "java"
	for i := 0; i < 10; i++ {
		data = append(data, strconv.Itoa(i))
	}
	fmt.Println(data)
}

func main() {
	//slice 底层原理

	//对于前边内容的一个补充
	fmt.Printf("%T, %T\n", [...]string{}, []string{}) //[0]string, []string

	/*
		go的slice在函数参数传递的时候是值传递，
		但是效果又呈现出了引用的效果（不完全是）
	*/
	//现象引入：
	course := []string{"go", "grpc", "gin"}
	printSlice(course)  ////[java grpc gin 0 1 2 3 4 5 6 7 8 9]
	fmt.Println(course) //[java grpc gin]

}

```

+ slice原理

```go

// slice 结构体
type slice struct {
	array unsafe.Pointer //用来存储实际数据的数组指针，指向一块连续的内存
	len   int            //切片中元素数量
	cap   int            //array数组的长度、容量
}
//在go语言中，结构体传递为值传递，会拷贝一份

```

`myslice:=[]string{"go","grpc","gin"}`为语法糖，在编译时会转换成：

```
myslice := slice{
	array指向数组
	len:3
	cap:3
}
```

在使用make方法时 `myslice:=make([]string,5,10)`，在底层表示为，len：5，cap：10，如图。<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517235239217.png" alt="image-20240517235239217" style="zoom: 67%;" />

当我们使用append方法时，当cap不够会扩容，生成新数组并将原数组拷贝过来，非常耗时。

有可能一开始我们自己初始化一个数组，然后选取1-4， 3个元素。

即下图。<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517235438675.png" alt="image-20240517235438675" style="zoom:67%;" />

当我们函数参数传递时，会拷贝结构体：![image-20240517235810710](./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517235810710.png)

虽然说是值传递，但是指针指向同一个底层数组，所以会出现引用传递的效果。

也可能两个slice通过同一个数组（长度为10）生成，切的位置不一样：![image-20240518000049611](./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240518000049611.png)

这样指向的也是同一个数组，前者cap=9，后者cap=8，如果后者发生扩容，就指向两个不同的数组了![image-20240518000736413](./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240518000736413.png)

此时再修改数据就互不影响了；这也就是为啥append的第一个参数要和返回值要一致，因为是值传递且有可能扩容。

```go
package main

import (
	"fmt"
	"strconv"
)

func printSlice(data []string) {
	data[0] = "java"
	for i := 0; i < 10; i++ {
		data = append(data, strconv.Itoa(i))
	}
	fmt.Println(data)
}

func main() {
	//slice 底层原理

	//对于前边内容的一个补充
	fmt.Printf("%T, %T\n", [...]string{}, []string{}) //[0]string, []string

	/*
		go的slice在函数参数传递的时候是值传递，
		但是效果又呈现出了引用的效果（不完全是）
	*/
	//现象引入：
	course := []string{"go", "grpc", "gin"}
	printSlice(course)  ////[java grpc gin 0 1 2 3 4 5 6 7 8 9]
	fmt.Println(course) //[java grpc gin]

	/*
		type slice struct {
			array unsafe.Pointer //用来存储实际数据的数组指针，指向一块连续的内存
			len   int            //切片中元素数量
			cap   int            //array数组的长度
		}
	*/

	// 原理：

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	s1 := data[3:6]
	s2 := data[2:7]
	s2[1] = 22
	fmt.Println(s1)               //[22 5 6]
	fmt.Println(s2)               //[3 22 5 6 7]
	fmt.Println(len(s1), cap(s1)) //3 7
	fmt.Println(len(s2), cap(s2)) //5,8

	s2 = append(s2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 1, 1)
	s2[1] = 33
	fmt.Println(s1)               //[22 5 6]，扩容后就不影响了
	fmt.Println(s2)               //[3 33 5 6 7 1 2 3 4 5 6 7 8 9 1 1 1]
	fmt.Println(len(s1), cap(s1)) //3 7
	fmt.Println(len(s2), cap(s2)) //17 18

    //查看扩容机制
	var data1 []int
	for i := 0; i < 2000; i++ {
		data1 = append(data1, i)
		fmt.Printf("len: %d, cap: %d\n", len(data1), cap(data1))
	}
}

```



## map

```go
package main

import "fmt"

func main() {
	//map,无序集合，主要是查询方便；数组切片需要遍历，map不需要

	/*
	 	1、定义
	*/
	var courseMap = map[string]string{
		"go":   "go攻城狮",
		"grpc": "grpc入门",
		"gin":  "深入理解",
	}
	/*
		2、取值
	*/
	fmt.Println(courseMap["gin"]) //深入理解

	/*
		3、放值
		4、两种初始化方法
		5、map必须初始化才能使用，slice可以不初始化
	*/
	courseMap["mysql"] = "数据库"
	fmt.Println(courseMap) //map[gin:深入理解 go:go攻城狮 grpc:grpc入门 mysql:数据库]

	//map类型要想放值必要要初始化
	//var courseMap1 map[string]string //没初始化，为nil
	//courseMap1["mysql"] = "数据库"      //报错，不能在nil map上添加
	//var courseMap1 map[string]string{}//这样初始化了，就不会报错

	// 使用make初始化，make可以初始化 slice、map、channel
	var courseMap2 = make(map[string]string, 3)
	courseMap2["mysql"] = "数据库"
	fmt.Println(courseMap2) //map[mysql:数据库]

	var m []string
	if m == nil {
		fmt.Printf("yes~\n") //yes~
	}
	m = append(m, "golang")
	fmt.Println(m) //[golang]

	/*
		6、赋值
	*/
	courseMap2["mysql"] = "mysql1"
	courseMap2["db"] = "db1"
	fmt.Println(courseMap2) //map[db:db1 mysql:mysql1]

	/*
		7、遍历
			- 无序，不保证每次打印都是相同顺序
			- map的key类型固定，只能是string、int...
			- value类型随意
	*/
	for k, v := range courseMap2 {
		fmt.Println(k, v)
		//mysql mysql1
		//db db1
	}
	//不需要key值
	for _, v := range courseMap2 {
		fmt.Println(v)
		//db1
		//mysql1
	}
	// 只有一个值，打印的是key！！！
	for key := range courseMap2 {
		fmt.Println(key)
		//mysql
		//db
	}

	/*
		8、获取map中的元素
	*/
	fmt.Println(courseMap2["go"]) //不能通过这样判断go是否在map中,这样返回空，无法判断
	fmt.Println(courseMap2)       //map[db:db1 mysql:mysql1]

	v, ok := courseMap2["go"]
	if ok {
		fmt.Println("in...", v)
	} else {
		fmt.Println("not in...") //not in...
	}
	//也可以这样写
	if v, ok := courseMap2["mysql"]; ok {
		fmt.Println("in...", v) //in... mysql1
	} else {
		fmt.Println("not in...")
	}
	if _, ok := courseMap2["db"]; ok {
		fmt.Println("in...") //in...
	} else {
		fmt.Println("not in...")
	}

	/*
		9、删除元素
	*/
	delete(courseMap2, "db")
	fmt.Println(courseMap2) //map[mysql:mysql1]

	//删除一个不存在的
	delete(courseMap2, "db") //不报错

	/*
		10、提示
			- map线程不安全
			-并发编程，要使用sync.map
	*/
}

```

## list

list是链表，底层存储空间不连续。

slice是动态数组，在不断地添加数据过程中会不断扩容，不断地分配空间，扩容过程中会对数据进行拷贝。而且slice要求底层存储为连续的空间，如果内存没有足够的连续空间，无法分配。

```go
package main

import (
	"container/list"
	"fmt"
)

func main() {
	// list

	/*
		1、list初始化
		2、首尾插入元素
	*/

	//两种初始化
	//var mylist list.List
	var mylist = list.New()

	mylist.PushBack("go")
	mylist.PushFront("go1")
	mylist.PushBack("go2")
	fmt.Println(mylist) //{{0xc000108120 0xc000108150 <nil> <nil>} 3}

	/*
		3、遍历
	*/

	//正向遍历
	for i := mylist.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
		//go1
		//go
		//go2
	}
	//反向遍历
	for j := mylist.Back(); j != nil; j = j.Prev() {
		fmt.Println(j.Value)
		//go2
		//go
		//go1
	}
	/*
		4、中间插入元素
	*/
	//在go前边插入go0.5
	i := mylist.Front()
	for ; i != nil; i = i.Next() {
		if i.Value.(string) == "go" {
			break
		}
	}
	mylist.InsertBefore("go0.5", i)
	for i := mylist.Front(); i != nil; i = i.Next() {
		fmt.Print(i.Value, " ") //go1 go0.5 go go2
	}
	fmt.Println()
	fmt.Println(i.Value) //go

	/*
		5、删除元素
	*/
	mylist.Remove(i)
	for i := mylist.Front(); i != nil; i = i.Next() {
		fmt.Print(i.Value, " ") //go1 go0.5 go2
	}
}

```

# 函数

+ 函数定义
+ 变长参数
+ 函数一等公民
    + 像变量一样赋值、作为参数传递
    + 匿名函数
    + 闭包
+ defer
+ error、panic、recover

```go
package main

import (
	"errors"
	"fmt"
)

/*
	1、函数的定义
	2、变长参数
*/

//	func 函数名(参数1 类型1，参数2 类型2 ...) (返回值类型1，返回值类型2 ...){
//			return 0	//返回值可以没有、1个、多个
//	}

// 定义一个求和函数
// func add(a int, b int) int {
// 也可以这样写
func add(a, b int) (int, error) {
	return a + b, nil
}

// 求和函数、也可以这样写
func add0(a, b int, c float64) (sum int, err error) {
	fmt.Println(a, b, c)
	sum = a + b
	//return sum, nil
	err = nil
	// 如果上边我们已经定义好sum、err了，也可以只写return
	return
}

// 变长参数
func add1(a ...int) (sum int) {
	fmt.Printf("%T\n", a) // []int、slice类型
	for _, v := range a {
		sum += v
	}
	return
}

// 函数返回值为函数
func cal(op string, item ...int) func() {
	switch op {
	case "+":
		return func() {
			fmt.Printf("这是加法 \n")
		}
	case "-":
		return func() {
			fmt.Printf("这是减法 \n")
		}
	default:
		return func() {
			fmt.Println("其他运算。。。")
		}
	}
}

// 函数作为参数
func cal1(myfunc func(item ...int) int) int {
	return myfunc()
}

// 定义一个全局变量
var local int

// 每次调用函数，全局变量+1
func autoIncrement() int {
	local += 1
	return local
}

// 闭包
func autoIncrement1() func() int {
	local := 0
	//一个函数不能访问另一个函数的局部变量
	//但是在一个函数中定义匿名函数，匿名函数是可以访问该函数的局部变量的---闭包

	return func() int {
		local += 1
		return local
	}
}

// defer使用
func deferReturn() (ret int) {
	defer func() {
		ret++ //defer有能力修改函数返回值
	}()
	return 10
}

// 返回error
func A() (int, error) {
	return 1, errors.New("this is an error")
}

// panic
func B() (int, error) {
	panic("this is a panic") //会导致程序退出
}

func main() {
	/*
		- go函数支持普通函数、匿名函数、闭包
		- go中函数是“一等公民”
			- 函数本身可以当做变量
			- 匿名函数、闭包
			- 函数满足接口
		- go语言中，函数参数全是值传递

	*/
	fmt.Println(add(1, 2))     //3 <nil>
	fmt.Println(add1(1, 2, 3)) //6

	/*
		3、函数一等公民
	*/

	//函数可以像变量一样赋值
	funcVar := add             //这里不能有（），不然就成调用函数了
	fmt.Println(funcVar(3, 3)) //6 <nil>

	//函数返回函数
	cal("+")() //这是加法

	//函数作为参数传递
	fmt.Println(cal1(func(item ...int) int {
		return 1
	})) //1

	// 匿名函数
	myFunc := func() {
		fmt.Println("hello1") //hello1
	}
	myFunc()
	func() {
		fmt.Println("hello2") //hello2
	}()

	/*
		4、go函数闭包性
			- 需求：
				-希望有个函数每调用一次返回结果都是增加一次之后的值
	*/
	//这种解决方案需要额外定义一个全局变量
	for i := 0; i < 5; i++ {
		fmt.Print(autoIncrement(), " ") //1 2 3 4 5
	}
	fmt.Println()
	//不需要定义全局变量也能实现每次调用+1
	next := autoIncrement1() //返回函数
	for i := 0; i < 5; i++ {
		fmt.Print(next(), " ") //1 2 3 4 5
	}
	fmt.Println()
	//如何归0---再定义一个next1
	next1 := autoIncrement1() //返回函数
	for i := 0; i < 5; i++ {
		fmt.Print(next1(), " ") //1 2 3 4 5
	}
	fmt.Println()

	/*
		5、函数中的defer
			-连接数据库、打开文件、开始锁，无论如何最后都要记得去关闭数据库、关闭文件、解锁
	*/
	//var mu sync.Mutex
	//mu.Lock()
	//defer mu.Unlock() //defer后面的代码会放在函数return之前执行

	//如果有多个defer,执行顺序（类似栈，前面的defer后执行）：
	//defer fmt.Print("1", " ")
	//fmt.Print("3", " ")
	//defer fmt.Print("2", " ")
	//输出顺序：3 2 1

	ret := deferReturn()
	fmt.Println(ret) //11~

	/*
		6、error设计理念
			go语言错误处理
				- error 值
				- panic 函数
				- recover 函数
			go语言错误处理理念
				- 其他语言 try...catch...
				- 如果函数出错，函数返回error值去告诉调用者是否成功，要求必须处理error，不能往上抛
					- 因此代码大量出现 if err!=nil
					- 也叫防御性编程
	*/
	_, err := A()
	if err != nil {
		fmt.Println(err) //this is an error
	}
	//也可以这样简洁写：
	if _, err := A(); err != nil {
		fmt.Println(err) //this is an error
	}

	/*
		7、panic & recover
			- 会导致程序退出
			- 使用场景：
				-比如我的服务想要启动，必须有些依赖服务准备好，日志文件存在、mysql能链接通、比如配置文件没有问题，这个时候服务才能肩动
				 如果我们的服务启动检查中发现了这些任何一个不满足那就调用panic
			- 即使我们没写panic，也会触发，比如map没初始化就添加值
				- 引出 recover
					- 可以捕获panic，避免程序因某个异常而崩掉
					- defer需要放在panic之前定义，另外recover只有在defer调用的函数中才会生效
					- recover处理异常后，逻辑并不会恢复到panic的那个点去,而是直接return
					- 多个defer会形成栈，后定义的defer.会先执行
	*/
	//B() //报错，panic: this is a panic

	//map没有初始化就添加值没有初始化
	//var names map[string]string //没有初始化
	//names["go"] = "123"         //会出错，panic: assignment to entry in nil map

	// recover 使用
	defer func() { //注意要放在出现会panic错误代码的前边！！！
		if r := recover(); r != nil {
			fmt.Println("没事了~", r) //没事了~ assignment to entry in nil map
		}
	}()
	var names map[string]string
	names["go"] = "123" //不报错了~，因为panic被recover捕获了
	fmt.Println(names)

}

```

# 结构体

+ type关键字
+ 结构体定义、初始化
+ 匿名结构体
+ 结构体嵌套
+ 结构体定义方法

```go
package main

import (
	"fmt"
	"strconv"
)

// 基于基本类型自定义类型
type MyInt2 int

// 自定义一个类型，并扩展方法
func (mi MyInt2) string() string {
	return strconv.Itoa(int(mi))
}

// 想要放多个person的信息到一个集合中
var persons [][]string

// 定义结构体
type Person struct {
	name   string
	age    int
	addr   string
	height float32
}

// 结构体嵌套
//   - 第一种嵌套方式
type Student struct {
	p     Person
	score float32
}

// - 第二种嵌套-匿名嵌套
type Student1 struct {
	Person
	score float32
}

// - 匿名嵌套---覆盖效果
type Student2 struct {
	Person
	name string
}

// 在Person结构体上定义方法
// func 接收器 方法名() (返回值类型){}
// 接收器有两种形态
//   - 第一种，值传递
func (p Person) print() {
	p.name = "111"
	fmt.Printf("name:%s,age:%d,addr:%s,height:%f\n", p.name, p.age, p.addr, p.height)
}

// - 第二种，指针,数据较大时，考虑指针传递
func (p *Person) print1() {
	p.name = "111"
	//这里我们无需将结构体值从指针中取出来，而是直接使用指针获取name、age...
	// 因为go语言在结构体指针这做了优化
	fmt.Printf("name:%s,age:%d,addr:%s,height:%f\n", p.name, p.age, p.addr, p.height)
}

func main() {

	/*
		1、type关键字
			- 定义结构体
			- 定义接口
			- 定义类型别名
				- 别名是为了更好地理解代码
			- 类型定义
				- 基于已有类型自定义一个类型
				- 扩展方法
			- 类型判断
	*/
	// 类型别名
	type MyInt = int
	var i MyInt = 12      //在编译时，MyInt会转换成int
	fmt.Printf("%T\n", i) //int
	var j int = -2
	fmt.Println(i + j) //10

	//  自定义类型
	type MyInt1 int
	var i1 MyInt1 = 12
	fmt.Printf("%T\n", i1)   //main.MyInt1
	fmt.Println(int(i1) + j) //10

	var i2 MyInt2 = 12
	fmt.Println(i2.string()) //12

	//类型判断
	var a interface{} = "abc"
	//判断类型,type拿到真正类型
	switch a.(type) {
	case string:
		fmt.Println("a string") //a string
	}
	//类型断言
	m := a.(string)
	fmt.Println(m) //abc

	/*
		2、结构体定义、初始化
	*/
	//这样比较麻烦
	persons = append(persons, []string{"a", "b", "c", "d"})
	persons = append(persons, []string{"a", "b", "c"})
	fmt.Println(persons) //[[a b c d] [a b c]]
	// 初始化结构体
	//这种初始化必须全部给值，且必须顺序对应上
	p1 := Person{
		"tom",
		15,
		"北京",
		1.80,
	}
	// 这种初始化可以不全给值
	fmt.Println(p1) //{tom 15 北京 1.8}
	p2 := Person{
		name: "baby",
	}
	fmt.Println(p2) //{baby 0  0}

	var persons []Person
	persons = append(persons, p1)
	persons = append(persons, p2)
	persons = append(persons, Person{
		name: "zhang3",
	})
	fmt.Println(persons) //[{tom 15 北京 1.8} {baby 0  0} {zhang3 0  0}]

	persons2 := []Person{
		{
			name: "a",
		},
		{
			"b", 13, "h", 8,
		},
	}
	fmt.Println(persons2) //[{a 0  0} {b 13 h 8}]

	// 结构体也可以这样赋值
	var p Person
	p.name = "tom"
	fmt.Println(p.name) //tom

	/*
		3、匿名结构体
	*/
	//先声明、并实例化好
	adddres := struct {
		province string
		city     string
		address  string
	}{
		"北京市", "朝阳区", "酒店",
	}
	fmt.Println(adddres) //{北京市 朝阳区 酒店}

	/*
		4、结构体的嵌套
	*/
	s := Student{
		p1,
		99,
	}
	fmt.Println(s) //{{tom 15 北京 1.8} 99}

	//这种赋值比较麻烦，因为每次写都有中间p，这就引入匿名嵌套
	s1 := Student{}
	s1.p.name = "tom"
	fmt.Println(s1.p.name) //tom

	// 匿名嵌套---只是访问方便了，初始化是仍然要走p
	s2 := Student1{}
	s2.name = "tom"
	fmt.Println(s2.name) //tom
	// 匿名嵌套---初始化
	s3 := Student1{
		//name:"tom",//报错，要走p
		Person{
			name: "tom",
		},
		99,
	}
	fmt.Println(s3) //{{tom 0  0} 99}

	//匿名嵌套 --- 覆盖效果
	s4 := Student2{}
	s4.Person.name = "111"
	s4.name = "222"
	fmt.Println(s4) //{{111 0  0} 222}

	/*
		5、结构体绑定方法
	*/
	// 接收器---值传递
	p1.print()           //name:111,age:15,addr:北京,height:1.800000
	s1.p.print()         //name:111,age:0,addr:,height:0.000000
	s3.print()           //name:111,age:0,addr:,height:0.000000
	fmt.Println(p1.name) //tom

	//接收器 --- 引用传递
	p1.print1()          //name:111,age:15,addr:北京,height:1.800000
	fmt.Println(p1.name) //111

	// 指针可以调用值绑定的方法，值可以调用指针上绑定的方法；这俩定义的方法名不能重复
	pp := &Person{
		name: "pp",
	}
	pp.print()  //name:111,age:0,addr:,height:0.000000
	p1.print1() //name:111,age:15,addr:北京,height:1.800000
}

```



# 指针



# 接口





