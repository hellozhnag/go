# goland快捷键

> 设置-->按键映射-->安装Eclipse快捷键插件

| 快捷键  | 作用 |
| --- | --- |
| CTRL+D |  删除一行代码    |
| ALT+<- | 退出代码     |
|     ALT+->   |     进入代码         |
|        |              |

# go语言基础

## HelloWorld

```go
package main

import "fmt"

func main() {
	fmt.Println("hello world")
}

```

> 编译：go build .\hello.go
>
> 编译运行：go run .\hello.go 

要设置package main并有main函数，这个go文件才能编译运行

同一个目录中的所有go文件只能有一个main函数，否则报错，goland不报错是因为<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240516224259107.png" alt="image-20240516224259107" style="zoom:50%;" />



## 变量

### 变量定义

```go
package main

import "fmt"

// 定义在main函数外为全局变量
// 这里定义的全局变量没有用到不会报错
// var name = "tom"
// var ok bool //布尔类型默认值false
// 上面两行代码通常这样写：
var (
	name = "tom"
	ok   bool
)

//简洁变量定义不能作用于全局变量
//age:=1 //报错

func main() {
	//go是静态语言
	/*
		1、变量先定义后使用
		2、变量必须有类型
		3、类型定义后不能改变
		4、同一作用域 变量名不能冲突
		5、简洁变量定义不能作用于全局变量
		6、变量有默认值
	*/

	//变相定义方式：
	//var age int=1 //类型定义在后边
	//var age=1		//int可省略，自动类型推断
	age := 100 //:=为赋值符号，可以省略var
	//go语言中局部变量定义后不使用会报错
	fmt.Println(age)

	//多变量定义
	//var user1, user2, user3 string //默认为空字符串
	var user1, user2, user3 = "tom1", 1, "tom3"
	fmt.Println(user1, user2, user3)

}

```

### 匿名变量

```go
package main

import "fmt"

// 定义一个函数
func a() (int, bool) {
	return 0, false
}

func main() {
	// 匿名变量，定义后但是不想使用
	var _ int
	//比如这里的r1我们不关心，我们只关心返回ok值有没有成功
	//r1, ok := a()
	_, ok := a() //改成匿名变量接收
	if ok {
		//如果不使用 _ 匿名变量接收，那我们必须要使用下r1变量，否则报错
		//fmt.Println(r1)
	}

}

```

### 变量作用域

```go
package main

import "fmt"

func main() {
	/*
		变量的作用域为定义的{}中
	*/

	{
		name := "hah"
		fmt.Println(name) //hah
	}
	//fmt.Println(name)//访问不到

	var age = 100
	if age == 100 {
		age := 1
		fmt.Println(age) //1
	}
	fmt.Println(age) //100
}

```

## 常量

```go
package main

import "fmt"

func main() {
	//显式定义常量
	const PI float64 = 3.1415926
	//隐式定义
	const PI2 = 3.1415926

	//命名：大写，单词间使用_连接

	//可以一组常量定义
	const (
		UNKNOW = 1
		FEMALE = 2
		MALE   = 3
	)

	const (
		x int = 16
		y
		s = "abc"
		z
	)
	fmt.Println(x, y, s, z) //16 16 abc abc
	/* 默认规则：
	1、常量类型定义只支持 bool、数值（整数、浮点数、复数）、字符串
	2、不曾使用的常量 编译不报错
	3、定义时若没有设置类型和值，沿用前边
	*/
}

```

### iota

```GO
package main

import "fmt"

func main() {
	// iota，特殊常量，可以认为是一个可以被编译器修改的常量

	/*
		1、后续会自动递增
		2、自增类型默认int
		3、每次出现const关键字时 iota归0
	*/
	const (
		err1 = iota
		err2
		err25
		err3
		err4 = "haha"
		err5
		err6 = iota
		err7 = 100
		err8 = iota
	)
	fmt.Println(err1, err2, err25, err3, err4, err5, err6, err7, err8)
	// 0 1 2 3 haha haha 6 100 8

	const (
		errnew = iota
	)
	fmt.Println(errnew) //0

	const ha = iota
	const ha1 = iota
	fmt.Println(ha, ha1) //0 0
}

```

## 基本数据类型

	+ bool -true/false
 + 数值类型
    + 整数 -(u)int8/(u)int16/(u)int32/(u)int64
    + 浮点数 -float32/float64
    + 复数
    + byte -本质就是uint8，主要适用于存储字符
    + rune -本质是int32，也是字符
 + 字符和string

```go
package main

import "fmt"

func main() {
	var a int8
	var b int16
	var c int32
	var d int64
	fmt.Println(a, b, c, d)
	var e int //动态类型,根据我们操作系统位数来定义
	fmt.Println(e)

	//a=b //报错
	//b=a//报错
	a = int8(b)
	b = int16(a)

	var f1 float32 //最大是3.4e38
	var f2 float64 //最大1.8e308
	fmt.Println(f1, f2)

	var ch byte
	ch = 'a'
	fmt.Println(ch)            //97
	fmt.Printf("c=%c\n", ch+1) //c=b
	ch1 := 97
	fmt.Printf("c=%c\n", ch1) //c=a

	//如果我们处理的字符是英文字符，使用byte，如果有中文，用rune
	var c1 rune = '慕'        //单引号字符，双引号是字符串
	fmt.Printf("c=%c\n", c1) //c=慕

	var name string = "i am tom"
	fmt.Printf("%s\n", name)
}

```

### 类型转换

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// 数值类型相互转换
	var a int = 12
	var b = uint(a)

	var f float32 = 3.14
	var c = int32(f)
	fmt.Println(b, c) //12,3

	var f64 = float64(a)
	fmt.Println(f64) //12

	// go语言类型要求严格
	type IT int
	//var d IT = a//报错
	var d IT = IT(a)
	fmt.Println(d)

	//字符、数字 相互转换
	var istr = "12"
	myint, err := strconv.Atoi(istr) //字符串转数字可能出错
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(myint) //12

	mstr := strconv.Itoa(myint) //数字转字符串不会出错
	fmt.Println(mstr)           //12
}

```

### ParseXxx&FormatXxx

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {

	//一、字符串类型转其他基本类型
	// 1、字符串转换为float
	//这个地方如果写32会按照float32转换，但是函数仍然返回float64
	myf, err := strconv.ParseFloat("3.14", 64)
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(myf) //3.14

	//2、字符串转int
	// 8进制，64位
	parseInt, err := strconv.ParseInt("12", 8, 64)
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseInt) //10,12=8^0*2+8^1*1=10

	// 3、字符串转bool
	parseBool1, err := strconv.ParseBool("true")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool1) //true
	parseBool2, err := strconv.ParseBool("hello")
	if err != nil {
		fmt.Println("convert err!") //convert err!
	}
	fmt.Println(parseBool2) //false,转换失败的话，为默认值false
	parseBool3, err := strconv.ParseBool("1")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool3) //true,"1"->true
	parseBool4, err := strconv.ParseBool("0")
	if err != nil {
		fmt.Println("convert err!")
	}
	fmt.Println(parseBool4) //false，"0"->false
	parseBool5, err := strconv.ParseBool("12")
	if err != nil {
		fmt.Println("convert err!") //convert err!
	}
	fmt.Println(parseBool5) //false,转换失败

	//二、基本类型转字符串
	formatBool := strconv.FormatBool(true)
	fmt.Println(formatBool) //true

	float := strconv.FormatFloat(3.14, 'E', -1, 64)
	fmt.Println(float) //3.14E+00

	//转换为16进制
	formatInt := strconv.FormatInt(42, 16)
	fmt.Println(formatInt) //2a,16^0*10+16^1*2=42

}

```

## 运算符与表达式

+ 算数运算符：+、-、*、/、++ ...
+ 逻辑运算符：||、&&、！
+ 位运算符：&、|、^、>>、<< ...（在底层库中常见，注重性能）
    + ^ 异或，不同为1，相同为0
    + A=60(二进制：0011 1100)，B=13(二进制：0000 1101)
        + A^B=0011 0001
+ 赋值运算符：+=、-=、*= 、/=、%=、&= ...
+ 取地址符：&
+ 指针类型：*

运算符优先级：

<img src="./images/01_go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.images/image-20240517125118179.png" alt="image-20240517125118179" style="zoom:60%;" />

## 字符串基本操作

### 字符和字符串处理

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	s := "ha慕课"
	//len方法获取字节长度
	fmt.Println(len(s)) //8
	//在utf8中，英文占一个字节，中文占三个字节
	fmt.Println("%X\n", []byte(s)) //[104 97 230 133 149 232 175 190]

	for i, ch := range s {
		fmt.Printf("(%d %X)", i, ch)
		//（字节索引，Unicode码）
		//(0 68)
		//(1 61)
		//(2 6155) //中文字符占3字节即第2 3 4
		//(5 8BFE) //索引不连续
	}
	fmt.Println()
	// 查看字符串中字符数量
	fmt.Println("Rune count:", utf8.RuneCountInString(s)) //4

	//转换为字节数组
	bytes := []byte(s)
	for len(bytes) > 0 {
		ch, size := utf8.DecodeRune(bytes)
		bytes = bytes[size:]
		fmt.Printf("%c ", ch)
	}
	fmt.Println()

	/*
		转换为rune数组，就能通过索引获取每一个字符
	*/
	for i, ch := range []rune(s) {
		fmt.Printf("(%d %c)", i, ch)
	}
	fmt.Println()
}

```

### 转义符

+ `\n`---换行符

+ `\r`---回车
+ `\t`---水平制表
+ `\\`---`\`
+ `\'`---`'`
+ `\"`---`"`
+ `\?`---`?`

```go
package main

import "fmt"

func main() {
	name1 := "\tgo\"课程\""
	fmt.Println(name1) //	go"课程"

	name2 := `go
			 "课程"`
	fmt.Println(name2) //ln默认加了\r\n
}

```

### 格式化输出

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	uname := "tom"
	out := "hello " + uname
	fmt.Println(out)
	age := 18
	address := "china"
	mobile := "15936178333"
	fmt.Println("用户名:"+uname, "年龄:"+strconv.Itoa(age), "地址:"+address, "电话:"+mobile) //这个性能好
	fmt.Printf("用户名:%s,年龄:%d,地址:%s,电话:%s \r\n", uname, age, address, mobile)        //这个好维护
	userMsg := fmt.Sprintf("用户名:%s,年龄:%d,地址:%s,电话:%s \r\n", uname, age, address, mobile)
	fmt.Println(userMsg)
}

```

### 高性能字符串拼接

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
)

func main() {
	uname := "tom"
	out := "hello " + uname
	fmt.Println(out)
	age := 18

	//通过string的builder进行字符串拼接，高性能
	var builder strings.Builder
	builder.WriteString("用户名")
	builder.WriteString(uname)
	builder.WriteString("用户名")
	builder.WriteString(strconv.Itoa(age))
	re := builder.String()
	fmt.Println(re)

}

```

### 字符串的比较

```go
package main

import "fmt"

func main() {
	a := "hello"
	b := "hello"
	c := "bello"
	fmt.Println(a == b) //true
	fmt.Println(a > c)//true，因为h的assic码比b的assic码大
	
}

```

### 字符串操作常用方法

```go
package main

import (
	"fmt"
	"strings"
)

func main() {

	//strings常用方法
	name := "haha攻城狮"
	fmt.Println(strings.Contains(name, "狮"))              //true
	fmt.Println(len([]rune(name)))                        //7
	fmt.Println(strings.Count(name, "h"))                 //2
	fmt.Println(strings.Split(name, "攻城"))                //[haha 狮]
	fmt.Println(strings.HasPrefix(name, "ha"))            //true，作为前缀
	fmt.Println(strings.HasSuffix(name, "攻城狮"))           //true,作为后缀
	fmt.Println(strings.Index(name, "城"))                 //7，字符串存在则返回第一个字节位置
	fmt.Println(strings.IndexRune(name, []rune(name)[5])) //7,rune存在则返回第一个字节位置
	fmt.Println(strings.Replace(name, "ha", "hello", -1)) //hellohello攻城狮
	//-1表示全替换，1表示替换前一个，2表示替换前两个
	fmt.Println(strings.Replace(name, "ha", "hello", 1)) //hellohello攻城狮
	fmt.Println(strings.ToLower("GO"))                   //go
	fmt.Println(strings.Trim("##he#llo#", "#"))         //he#llo

}

```

## 条件判断和循环语句

+ if条件判断
+ for循环、break、continue、for range
+ goto
+ switch

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	/*
		1、if条件判断
	*/
	a := 18
	country := "china"
	if a < 18 {
		fmt.Println("未成年~")
	} else if a == 18 && country == "china" {
		fmt.Println("刚满18岁~")
	} else {
	}

	/*
		2、for循环，go不提供while循环
	*/
	//这仨都不是必须的
	for i := 0; i < 10; i++ {
		fmt.Println(i) //打印0~9
	}
	//这种写法 无限循环
	//for {
	//	fmt.Println("hi~")
	//}

	var j int
	for j <= 3 {
		fmt.Println(j)
		j++
	}

	/*
		3、for循环打印99乘法表
	*/
	for a := 1; a <= 9; a++ {
		for b := 1; b <= a; b++ {
			fmt.Printf("%dx%d=%d ", a, b, a*b)
		}
		fmt.Println()
	}

	/*
		4、for range的循环用法
		主要是对字符串、数组、切片、map、channel
	*/
	name := "hi耶,go"
	//字符串的索引（key）、字符串对应的索引的字符值的拷贝（value）
	for key, value := range name {
		fmt.Println(key, value)
		fmt.Printf("%d,%c \r\n", key, value)
		//0 104
		//0,h
		//1 105
		//1,i
		//2 32822
		//2,耶
		//5 44
		//5,,
		//6 103
		//6,g
		//7 111
		//7,o
	}
	//其他写法
	for _, value := range name {
		fmt.Println(value)
	}
	// 不写key，返回索引
	for index := range name {
		fmt.Print(index)
		//打印对应index的字符
		fmt.Printf("%c ", name[index]) //只针对英文

		//0h 1i 2è 5, 6g 7o
	}
	fmt.Println()

	/*
		5、for循环的 break & continue
	*/
	test := 0
	for {
		time.Sleep(1 * time.Second)
		test++
		if test == 3 {
			continue
		}
		fmt.Print(test, " ") // 1 2 4 5
		if test == 5 {
			break
		}
	}

	/*
		6、goto语句
			很少用，可读性差，不建议用
			使用场景多用于错误处理，出错统一跳转到相应标签处，统一处理
	*/
	for x := 0; x < 5; x++ {
		for y := 0; y < 5; y++ {
			if j == 2 {
				//假设我们想在这结束两层循环，break只能结束一层
				goto over
			}
		}
	}
over:
	fmt.Println("over...")

	/*
		7、switch语句
			代码更可读、执行效率更高
	*/
	day := "星期三"
	switch day {
	case "星期一":
		fmt.Println("Monday...")
	case "星期二":
		fmt.Println("Tuesday...")
	case "星期三":
		fmt.Println("Wednesday...")
	case "星期四":
		fmt.Println("Thursday...")
	default:
		fmt.Println("other...")
	}

	score := 60
	switch {
	case score < 60:
		fmt.Println("不及格。。。")
	case score >= 60 && score < 80:
		fmt.Println("良好...")
	case score >= 80:
		fmt.Println("优秀")
	}
	
	switch score {
	case 60, 70, 80:
		fmt.Println("恰好是60 70 80.。。")
	default:
		fmt.Println("other...")
	}
}

```

# 数组、切片、map







